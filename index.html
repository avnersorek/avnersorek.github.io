<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hello World â€” Whirlwind</title>

  <!-- IBM Plex Mono -->
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#07060a;
      --fg:#e9eef8;
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 800px at 10% 20%, #0b1020 0%, var(--bg) 35%, #020205 100%);
      color:var(--fg);
      font-family: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
      overflow:hidden;
    }

    /* centered Hello World in Plex Mono */
    #message{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      font-family: 'IBM Plex Mono', monospace;
      font-size:clamp(28px,6vw,84px);
      letter-spacing:0.04em;
      font-weight:600;
      color:var(--fg);
      text-align:center;
      z-index:3;
      pointer-events:none;
      transition:opacity 1s ease, transform 1s ease;
      text-shadow:
        0 6px 20px rgba(2,3,9,0.7),
        0 1px 0 rgba(255,255,255,0.02);
    }
    #message.faint{
      opacity:0.06;
      transform:translate(-50%,-50%) scale(0.98);
    }

    /* particle letters (small, mono) */
    .whirl-letter{
      position:fixed;
      left:0;
      top:0;
      transform-origin:center center;
      will-change:transform, opacity, filter;
      pointer-events:none;
      user-select:none;
      font-family:'IBM Plex Mono', monospace;
      font-weight:400;
      mix-blend-mode:screen;
      text-shadow:
        0 2px 6px rgba(0,0,0,0.5);
    }

    .vignette{
      position:fixed;
      inset:0;
      background:
        radial-gradient(60% 40% at 20% 30%, rgba(80,120,255,0.05), transparent 10%),
        radial-gradient(50% 35% at 80% 80%, rgba(255,140,200,0.03), transparent 12%);
      pointer-events:none;
      z-index:1;
    }

    @media (prefers-reduced-motion: reduce){
      .whirl-letter{ transition:none !important; animation:none !important; opacity:0 !important; }
    }
  </style>
</head>
<body>
  <div id="message">Hello World</div>
  <div class="vignette" aria-hidden="true"></div>

  <script>
  (function () {
    // Only letters from "hello world" (lowercase)
    const LETTERS = 'helloworld';
    const idleDelay = 5000; // ms before auto-start
    const rampDuration = 12000; // ms to go from slow to full speed
    let idleTimer = null;
    let animating = false;
    let rafId = null;

    const message = document.getElementById('message');

    // Respect reduced motion preference
    const reduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (reduced) {
      // keep simple message visible and do nothing else
      return;
    }

    // Interaction resets idle and stops animation
    const activityEvents = ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll'];
    activityEvents.forEach(e => window.addEventListener(e, resetIdle, { passive: true }));

    resetIdle();

    function resetIdle(){
      if (idleTimer) clearTimeout(idleTimer);
      if (animating) stopAnimation();
      idleTimer = setTimeout(() => startAnimation(), idleDelay);
    }

    function startAnimation(){
      animating = true;
      message.classList.add('faint');
      // create runtime state
      startTime = performance.now();
      lastTime = startTime;
      particles = [];
      streams = [];
      spawnAccumulator = 0;
      initStreams(3); // start with a few streams
      rafId = requestAnimationFrame(frame);
    }

    function stopAnimation(){
      animating = false;
      message.classList.remove('faint');
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      // remove DOM nodes
      particles.forEach(p => p.el.remove());
      particles = [];
      streams = [];
    }

    // Particles currently on screen
    let particles = [];
    // Streams that emit letters (to create trailing "horizontal columns" like rotated Matrix)
    let streams = [];
    // Accumulators
    let spawnAccumulator = 0;
    let startTime = 0;
    let lastTime = 0;

    // Config: ranges for speeds and counts
    const config = {
      spawnRateMin: 6,        // letters/sec at start (global)
      spawnRateMax: 220,      // letters/sec at full speed
      streamsMin: 3,
      streamsMaxPerHeight: 0.025, // fraction of vh -> stream count = vh * this
      particleLifeMin: 2600,  // ms
      particleLifeMax: 8200,  // ms
      vxMin: 40,              // px/s at start
      vxMax: 700,             // px/s at top speed
      verticalJitter: 30,     // px amplitude for leaf-like flutter
      maxParticles: 1500,
    };

    function initStreams(count) {
      streams = [];
      const vh = window.innerHeight;
      for (let i = 0; i < count; i++) {
        const y = Math.random() * vh;
        streams.push(createStream(y));
      }
    }

    function createStream(y) {
      return {
        y,
        // phase to offset sine flutter
        phase: Math.random() * Math.PI * 2,
        // each stream has a small horizontal jitter to vary starting X a bit
        xOffset: -10 - Math.random() * 60,
        // small personal speed multiplier
        speedMul: 0.8 + Math.random() * 0.8,
        // emission accumulator per stream
        acc: 0
      };
    }

    // Spawn a particle at (x,y) moving rightwards
    function spawnParticle(x, y, vx, vy, life, ch, size, colorHue) {
      if (particles.length > config.maxParticles) return;
      const el = document.createElement('span');
      el.className = 'whirl-letter';
      el.textContent = ch;
      el.style.left = '0px';
      el.style.top = '0px';
      el.style.fontSize = `${size}px`;
      el.style.opacity = '0.98';
      el.style.zIndex = 2 + Math.floor(Math.random() * 20);
      // color tuned to a cool palette
      el.style.color = `hsl(${colorHue} ${60 + Math.random()*20}% ${58 + Math.random()*8}%)`;
      document.body.appendChild(el);

      particles.push({
        el,
        x, y,
        vx, vy,
        birth: performance.now(),
        life,
        size
      });
    }

    // Frame loop
    function frame(now) {
      const dt = Math.min(40, now - lastTime); // clamp to avoid jumps
      lastTime = now;
      const elapsed = now - startTime;
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      // Ramp factor (0 -> 1)
      const t = Math.min(1, elapsed / rampDuration);

      // compute current global spawn rate and speed based on ramp
      const spawnRate = lerp(config.spawnRateMin, config.spawnRateMax, easeOutCubic(t));
      const vxBase = lerp(config.vxMin, config.vxMax, easeOutCubic(t));

      // adjust number of streams gradually
      const targetStreams = Math.max(config.streamsMin, Math.min(40, Math.round(vh * config.streamsMaxPerHeight * (0.8 + t))));
      if (streams.length < targetStreams) {
        // add one new stream every 200ms of ramp
        if (Math.random() < 0.18) {
          const y = Math.random() * vh;
          streams.push(createStream(y));
        }
      } else if (streams.length > targetStreams) {
        streams.splice(0, streams.length - targetStreams);
      }

      // distribute spawnRate across streams but allow some random stray particles
      const spawnFromStreams = spawnRate * 0.86;
      const strayRate = spawnRate - spawnFromStreams;

      // accumulate and emit stray particles
      spawnAccumulator += (strayRate * dt / 1000);
      while (spawnAccumulator >= 1) {
        spawnAccumulator -= 1;
        // stray particle: random y, start slightly left
        const y = Math.random() * vh;
        const xStart = -20 - Math.random() * 80;
        const vx = vxBase * (0.7 + Math.random() * 0.9);
        const vy = (Math.random() * 2 - 1) * 30;
        const life = randomRange(config.particleLifeMin, config.particleLifeMax) * (0.7 + Math.random()*0.8);
        const ch = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
        const size = Math.max(9, Math.min(20, (Math.min(vw, vh) / 60) * (0.6 + Math.random())));
        const hue = (200 + Math.random() * 160) % 360;
        spawnParticle(xStart, y, vx, vy, life, ch, size, hue);
      }

      // each stream emits according to spawnFromStreams / streams.length
      const perStreamRate = spawnFromStreams / Math.max(1, streams.length);
      for (let si = 0; si < streams.length; si++) {
        const s = streams[si];
        s.acc += perStreamRate * dt / 1000;
        // occasionally adjust y a bit to mimic rising currents
        s.y += Math.sin((now + si*1234) * 0.0003 + s.phase) * 0.12;
        if (Math.random() < 0.002) {
          s.y += (Math.random() - 0.5) * 40;
          s.phase = Math.random() * Math.PI * 2;
        }
        while (s.acc >= 1) {
          s.acc -= 1;
          const yJitter = (Math.random() - 0.5) * 18;
          const y = clamp(s.y + yJitter, 10, vh - 10);
          const xStart = s.xOffset - (Math.random() * 20);
          const vx = vxBase * s.speedMul * (0.8 + Math.random() * 0.8);
          // vertical velocity small; flutter as sine will add movement
          const vy = (Math.random() * 2 - 1) * 26;
          const life = randomRange(config.particleLifeMin, config.particleLifeMax) * (0.6 + Math.random()*1.2);
          const ch = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
          const size = Math.max(8, Math.min(16, (Math.min(vw, vh) / 80) * (0.6 + Math.random())));
          const hue = (200 + si * 12 + Math.random() * 40) % 360;
          spawnParticle(xStart, y, vx, vy, life, ch, size, hue);
        }
      }

      // update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        const age = now - p.birth;
        if (age > p.life || p.x > vw + 60 || p.y < -80 || p.y > vh + 80) {
          p.el.remove();
          particles.splice(i, 1);
          continue;
        }
        // horizontal movement
        p.x += p.vx * (dt / 1000);
        // vertical movement plus fluttering to mimic leaves
        const flutter = Math.sin((now + i * 137) * 0.003 + i) * (config.verticalJitter * (0.2 + Math.sin(i) * 0.3));
        p.y += p.vy * (dt / 1000) + flutter * (dt / 1000);

        // slight rotation based on vx and flutter
        const rot = (Math.sin((p.x + p.y) * 0.002 + i) * 25) * (p.vx / (vxBase + 0.001));

        // opacity fades out towards end of life, also thin trailing feel
        const lifeProgress = age / p.life;
        const opacity = Math.max(0, 1 - lifeProgress);
        const scale = 0.85 + (1 - lifeProgress) * 0.6;

        // position and transform
        p.el.style.transform = `translate(${p.x}px, ${p.y}px) translate(-50%, -50%) rotate(${rot}deg) scale(${scale})`;
        p.el.style.opacity = Math.max(0.05, opacity).toFixed(3);
        // slight blur for depth
        p.el.style.filter = `blur(${Math.min(2.2, lifeProgress * 2)}px)`;
      }

      // schedule next frame if animating
      if (animating) rafId = requestAnimationFrame(frame);
    }

    // helpers
    function lerp(a, b, t) { return a + (b - a) * t; }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function randomRange(a, b) { return a + Math.random() * (b - a); }
    function easeOutCubic(x) { return 1 - Math.pow(1 - x, 3); }

    // Pause/resume on visibility change for efficiency
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      } else if (animating && !rafId) {
        lastTime = performance.now();
        rafId = requestAnimationFrame(frame);
      }
    });

    // Rebuild streams on resize to keep density correct
    let resizeTO;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTO);
      resizeTO = setTimeout(() => {
        if (animating) {
          // keep current particles but add/remove streams based on new height
          const vh = window.innerHeight;
          const targetStreams = Math.max(config.streamsMin, Math.min(40, Math.round(vh * config.streamsMaxPerHeight)));
          while (streams.length < targetStreams) streams.push(createStream(Math.random() * vh));
          while (streams.length > targetStreams) streams.pop();
        }
      }, 240);
      resetIdle();
    });

    // cleanup
    window.addEventListener('pagehide', () => {
      if (rafId) cancelAnimationFrame(rafId);
    });

    // Expose control for debugging
    window.__whirl = {
      start: startAnimation,
      stop: stopAnimation,
      resetIdle
    };
  })();
  </script>
</body>
</html>
