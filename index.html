<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>hello.avner.world.sorek.github.io</title>

  <!-- IBM Plex Mono -->
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#07060a;
      --fg:#e9eef8;
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 800px at 10% 20%, #0b1020 0%, var(--bg) 35%, #020205 100%);
      color:var(--fg);
      font-family: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
      overflow:hidden;
    }

    /* Hello World — large centered message (flies away as a single large element) */
    #message{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      font-family: 'IBM Plex Mono', monospace;
      font-size:clamp(28px,6vw,84px);
      letter-spacing:0.04em;
      font-weight:600;
      color:var(--fg);
      text-align:center;
      z-index:3;
      pointer-events:none;
      transition:opacity 0.8s ease, transform 0.8s ease;
      text-shadow:
        0 6px 20px rgba(2,3,9,0.7),
        0 1px 0 rgba(255,255,255,0.02);
      white-space:nowrap;
    }

    /* particle letters (small, mono) */
    .whirl-letter{
      position:fixed;
      left:0;
      top:0;
      transform-origin:center center;
      will-change:transform, opacity, filter;
      pointer-events:none;
      user-select:none;
      font-family:'IBM Plex Mono', monospace;
      font-weight:400;
      mix-blend-mode:screen;
      text-shadow:
        0 2px 6px rgba(0,0,0,0.5);
    }

    .vignette{
      position:fixed;
      inset:0;
      background:
        radial-gradient(60% 40% at 20% 30%, rgba(80,120,255,0.05), transparent 10%),
        radial-gradient(50% 35% at 80% 80%, rgba(255,140,200,0.03), transparent 12%);
      pointer-events:none;
      z-index:1;
    }

    @media (prefers-reduced-motion: reduce){
      .whirl-letter{ transition:none !important; animation:none !important; opacity:0 !important; }
    }
  </style>
</head>
<body>
  <div id="message">Hello World</div>
  <div class="vignette" aria-hidden="true"></div>

  <script>
  (function () {
    // Allowed letters from "hello world"
    const LETTERS = 'helloworld';

    // Base ramp and spawn config
    const rampDuration = 10000; // ms to ramp to full speed
    let idleTimer = null;
    let animating = false;
    let rafId = null;

    let message = document.getElementById('message');

    // Respect reduced motion
    const reduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (reduced) return;

    // Mouse movement tracking (to influence idle wait)
    const mouseSamples = []; // {x,y,t}
    const sampleWindow = 600; // ms window to compute speed
    const maxConsideredSpeed = 1200; // px/s maps to top of delay range

    // Delay range (ms) when deciding when to start animation based on movement
    const minDelay = 1200;
    const maxDelay = 7000;

    // Activity events: we track movement for delay but do NOT stop animation once started
    const activityEvents = ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll', 'touchmove'];
    activityEvents.forEach(e => window.addEventListener(e, onActivity, { passive: true }));

    // Also keep an explicit mousemove listener to capture fine-grained speed (including touchmove above)
    window.addEventListener('mousemove', captureMouse, { passive: true });
    window.addEventListener('touchmove', captureTouch, { passive: true });

    // initial schedule
    scheduleIdle();

    function captureMouse(ev) {
      const t = performance.now();
      mouseSamples.push({ x: ev.clientX, y: ev.clientY, t });
      pruneSamples(t);
    }

    function captureTouch(ev) {
      const t = performance.now();
      if (ev.touches && ev.touches[0]) {
        mouseSamples.push({ x: ev.touches[0].clientX, y: ev.touches[0].clientY, t });
        pruneSamples(t);
      }
    }

    function pruneSamples(now) {
      while (mouseSamples.length > 0 && now - mouseSamples[0].t > sampleWindow) mouseSamples.shift();
      // also keep sample array length reasonable
      if (mouseSamples.length > 30) mouseSamples.splice(0, mouseSamples.length - 30);
    }

    function computeAvgSpeed() {
      if (mouseSamples.length < 2) return 0;
      const first = mouseSamples[0];
      const last = mouseSamples[mouseSamples.length - 1];
      const dt = (last.t - first.t) / 1000; // seconds
      if (dt <= 0) return 0;
      let dist = 0;
      for (let i = 1; i < mouseSamples.length; i++) {
        const a = mouseSamples[i - 1];
        const b = mouseSamples[i];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        dist += Math.hypot(dx, dy);
      }
      const speed = dist / dt; // px/s
      return speed;
    }

    // When user activity happens, we reschedule the idle timer based on current movement.
    // IMPORTANT: do NOT stop the animation if it's already running.
    function onActivity(ev) {
      // capture movement from non-mouse events quickly
      if (ev.type === 'mousedown' && ev.clientX != null) {
        const t = performance.now();
        mouseSamples.push({ x: ev.clientX, y: ev.clientY, t });
        pruneSamples(t);
      }
      scheduleIdle();
    }

    function scheduleIdle() {
      if (idleTimer) clearTimeout(idleTimer);
      // compute speed and map to delay
      const speed = computeAvgSpeed();
      const speedNorm = Math.min(1, Math.max(0, speed / maxConsideredSpeed)); // 0..1
      const mappedDelay = Math.round(lerp(minDelay, maxDelay, speedNorm));
      // If animation already started, do not clear it later on activity — we only use the timer to start once.
      if (!animating) {
        idleTimer = setTimeout(() => {
          startAnimation();
        }, mappedDelay);
      }
    }

    // Core animation state
    let particles = [];
    let streams = [];
    let spawnAccumulator = 0;
    let startTime = 0;
    let lastTime = 0;

    const config = {
      spawnRateMin: 3,
      spawnRateMax: 120,
      streamsMin: 2,
      streamsMaxPerHeight: 0.012,
      particleLifeMin: 2400,
      particleLifeMax: 7000,
      vxMin: 60,
      vxMax: 520,
      verticalJitter: 28,
      maxParticles: 600, // further reduced for performance
    };

    function initStreams(count) {
      streams = [];
      const vh = window.innerHeight;
      for (let i = 0; i < count; i++) {
        streams.push(createStream(Math.random() * vh));
      }
    }

    function createStream(y) {
      return {
        y,
        phase: Math.random() * Math.PI * 2,
        xOffset: -12 - Math.random() * 40,
        speedMul: 0.8 + Math.random() * 0.7,
        acc: 0
      };
    }

    function spawnParticle(x, y, vx, vy, life, ch, size, colorHue) {
      if (particles.length > config.maxParticles) return;
      const el = document.createElement('span');
      el.className = 'whirl-letter';
      el.textContent = ch;
      el.style.left = '0px';
      el.style.top = '0px';
      el.style.fontSize = `${size}px`;
      el.style.opacity = '0.98';
      el.style.zIndex = 2 + Math.floor(Math.random() * 20);
      el.style.color = `hsl(${colorHue} ${58 + Math.random()*20}% ${56 + Math.random()*8}%)`;
      document.body.appendChild(el);

      particles.push({
        el,
        x, y,
        vx, vy,
        birth: performance.now(),
        life,
        size
      });
    }

    // Animate the central large message flying away (single large object).
    let _messageOriginal = null;
    let messageHasFlown = false;
    function animateMessageFly(){
      if (!message || messageHasFlown) return;
      messageHasFlown = true;
      _messageOriginal = {
        transform: message.style.transform || '',
        transition: message.style.transition || '',
        opacity: message.style.opacity || '',
        left: message.style.left || '',
        top: message.style.top || '',
        zIndex: message.style.zIndex || ''
      };

      message.style.transition = 'transform 2200ms cubic-bezier(.22,1,.36,1), opacity 1200ms ease';
      message.style.willChange = 'transform, opacity';
      void message.offsetWidth;

      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const finalX = Math.round(vw * (1.12 + Math.random() * 0.2));
      const finalY = Math.round((Math.random() - 0.5) * vh * 0.5);
      const angle = (Math.random() * 30 + 6) * (Math.random() < 0.5 ? -1 : 1);
      const finalScale = 0.95 + Math.random() * 0.12;

      setTimeout(() => {
        message.style.transform = `translate(${finalX}px, ${finalY}px) translate(-50%,-50%) rotate(${angle}deg) scale(${finalScale})`;
        message.style.opacity = '0.95';
      }, 16);

      // subtle continued drift after the main flight so it visually continues with the whirlwind
      setTimeout(() => {
        message.style.transition = 'transform 7000ms linear, opacity 3000ms linear';
        const extraX = Math.round(vw * 0.35);
        const extraY = finalY * 0.6;
        message.style.transform = `translate(${finalX + extraX}px, ${finalY + extraY}px) translate(-50%,-50%) rotate(${angle*1.2}deg) scale(${finalScale*0.96})`;
        message.style.opacity = '0.88';
      }, 2600);
    }

    function startAnimation(){
      if (animating) return; // already running
      animating = true;
      lastTime = performance.now();
      startTime = lastTime;
      particles = [];
      streams = [];
      spawnAccumulator = 0;

      initStreams(2);
      animateMessageFly();
      rafId = requestAnimationFrame(frame);
    }

    // We no longer stop animation on user interaction; it loops indefinitely until explicitly stopped.
    function stopAnimation(){
      animating = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      particles.forEach(p => p.el.remove());
      particles = [];
      streams = [];
      restoreMessage();
    }

    function restoreMessage(){
      // Try to restore original inline styles if needed
      message = document.getElementById('message');
      if (!message) return;
      if (_messageOriginal) {
        message.style.transition = 'none';
        void message.offsetWidth;
        message.style.transform = _messageOriginal.transform || 'translate(-50%,-50%)';
        message.style.left = _messageOriginal.left || '50%';
        message.style.top = _messageOriginal.top || '50%';
        message.style.opacity = _messageOriginal.opacity || '';
        message.style.zIndex = _messageOriginal.zIndex || '';
        setTimeout(() => {
          message.style.transition = _messageOriginal.transition || 'opacity 0.8s ease, transform 0.8s ease';
        }, 20);
      }
    }

    // Frame loop
    function frame(now) {
      const dt = Math.min(40, now - lastTime);
      lastTime = now;
      const elapsed = now - startTime;
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      const t = Math.min(1, elapsed / rampDuration);
      const spawnRate = lerp(config.spawnRateMin, config.spawnRateMax, easeOutCubic(t));
      const vxBase = lerp(config.vxMin, config.vxMax, easeOutCubic(t));

      const targetStreams = Math.max(config.streamsMin, Math.min(18, Math.round(vh * config.streamsMaxPerHeight * (0.9 + t))));
      if (streams.length < targetStreams) {
        if (Math.random() < 0.12) streams.push(createStream(Math.random() * vh));
      } else if (streams.length > targetStreams) {
        streams.splice(0, streams.length - targetStreams);
      }

      const spawnFromStreams = spawnRate * 0.82;
      const strayRate = spawnRate - spawnFromStreams;

      spawnAccumulator += (strayRate * dt / 1000);
      while (spawnAccumulator >= 1) {
        spawnAccumulator -= 1;
        const y = Math.random() * vh;
        const xStart = -20 - Math.random() * 80;
        const vx = vxBase * (0.7 + Math.random() * 0.8);
        const vy = (Math.random() * 2 - 1) * 24;
        const life = randomRange(config.particleLifeMin, config.particleLifeMax) * (0.8 + Math.random()*0.8);
        const ch = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
        const size = Math.max(8, Math.min(14, (Math.min(vw, vh) / 80) * (0.6 + Math.random())));
        const hue = (200 + Math.random() * 160) % 360;
        spawnParticle(xStart, y, vx, vy, life, ch, size, hue);
      }

      const perStreamRate = spawnFromStreams / Math.max(1, streams.length);
      for (let si = 0; si < streams.length; si++) {
        const s = streams[si];
        s.acc += perStreamRate * dt / 1000;
        s.y += Math.sin((now + si*1009) * 0.00026 + s.phase) * 0.08;
        if (Math.random() < 0.002) {
          s.y += (Math.random() - 0.5) * 36;
          s.phase = Math.random() * Math.PI * 2;
        }
        while (s.acc >= 1) {
          s.acc -= 1;
          const yJitter = (Math.random() - 0.5) * 14;
          const y = clamp(s.y + yJitter, 8, vh - 8);
          const xStart = s.xOffset - (Math.random() * 18);
          const vx = vxBase * s.speedMul * (0.85 + Math.random() * 0.5);
          const vy = (Math.random() * 2 - 1) * 18;
          const life = randomRange(config.particleLifeMin, config.particleLifeMax) * (0.8 + Math.random()*1.0);
          const ch = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
          const size = Math.max(7, Math.min(12, (Math.min(vw, vh) / 100) * (0.6 + Math.random())));
          const hue = (200 + si * 10 + Math.random() * 36) % 360;
          spawnParticle(xStart, y, vx, vy, life, ch, size, hue);
        }
      }

      // update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        const age = now - p.birth;
        if (age > p.life || p.x > vw + 80 || p.y < -120 || p.y > vh + 120) {
          p.el.remove();
          particles.splice(i, 1);
          continue;
        }
        p.x += p.vx * (dt / 1000);
        const flutter = Math.sin((now * 0.003) + i) * (config.verticalJitter * (0.2 + Math.sin(i)*0.2));
        p.y += p.vy * (dt / 1000) + flutter * (dt / 1000);
        const rot = (Math.sin((p.x + p.y) * 0.002 + i) * 24) * (p.vx / (vxBase + 0.001));
        const lifeProgress = age / p.life;
        const opacity = Math.max(0, 1 - lifeProgress);
        const scale = 0.82 + (1 - lifeProgress) * 0.5;
        p.el.style.transform = `translate(${p.x}px, ${p.y}px) translate(-50%, -50%) rotate(${rot}deg) scale(${scale})`;
        p.el.style.opacity = Math.max(0.04, opacity).toFixed(3);
        p.el.style.filter = `blur(${Math.min(1.6, lifeProgress * 2)}px)`;
      }

      if (animating) rafId = requestAnimationFrame(frame);
    }

    // Helpers
    function lerp(a, b, t) { return a + (b - a) * t; }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function randomRange(a, b) { return a + Math.random() * (b - a); }
    function easeOutCubic(x) { return 1 - Math.pow(1 - x, 3); }

    // Pause/resume on visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      } else if (animating && !rafId) {
        lastTime = performance.now();
        rafId = requestAnimationFrame(frame);
      }
    });

    // Rebuild streams on resize
    let resizeTO;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTO);
      resizeTO = setTimeout(() => {
        if (animating) {
          const vh = window.innerHeight;
          const targetStreams = Math.max(config.streamsMin, Math.min(18, Math.round(vh * config.streamsMaxPerHeight)));
          while (streams.length < targetStreams) streams.push(createStream(Math.random() * vh));
          while (streams.length > targetStreams) streams.pop();
        }
      }, 220);
      scheduleIdle();
    });

    // Cleanup on pagehide
    window.addEventListener('pagehide', () => {
      if (rafId) cancelAnimationFrame(rafId);
    });

    // Expose control
    window.__whirl = {
      start: startAnimation,
      stop: stopAnimation,
      scheduleIdle
    };
  })();
  </script>
</body>
</html>
