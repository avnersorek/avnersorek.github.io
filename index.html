<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>hello.avner.sorek.github.world.io</title>

  <!-- IBM Plex Mono -->
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#07060a;
      --fg:#e9eef8;
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 800px at 10% 20%, #0b1020 0%, var(--bg) 35%, #020205 100%);
      color:var(--fg);
      font-family: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
      overflow:hidden;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* large independent letters */
    .big-letter{
      position:fixed;
      left:0;
      top:0;
      transform-origin:center center;
      will-change:transform, opacity;
      pointer-events:none;
      user-select:none;
      font-family:'IBM Plex Mono', monospace;
      font-weight:600;
      color:var(--fg);
      z-index:4;
      text-shadow:
        0 6px 18px rgba(2,3,9,0.7),
        0 1px 0 rgba(255,255,255,0.02);
      white-space:pre;
      backface-visibility:hidden;
      -webkit-transform: translate3d(0,0,0);
      transform-style:preserve-3d;
    }

    /* particle letters (small, mono) */
    .whirl-letter{
      position:fixed;
      left:0;
      top:0;
      transform-origin:center center;
      will-change:transform, opacity;
      pointer-events:none;
      user-select:none;
      font-family:'IBM Plex Mono', monospace;
      font-weight:400;
      color:rgba(230,240,255,0.98);
      text-shadow: 0 2px 6px rgba(0,0,0,0.45);
      white-space:pre;
      backface-visibility:hidden;
      -webkit-transform: translate3d(0,0,0);
    }

    .vignette{
      position:fixed;
      inset:0;
      background:
        radial-gradient(60% 40% at 20% 30%, rgba(80,120,255,0.05), transparent 10%),
        radial-gradient(50% 35% at 80% 80%, rgba(255,140,200,0.03), transparent 12%);
      pointer-events:none;
      z-index:1;
    }

    @media (prefers-reduced-motion: reduce){
      .whirl-letter{ transition:none !important; animation:none !important; opacity:0 !important; }
      .big-letter{ transition:none !important; animation:none !important; }
    }
  </style>
</head>
<body>
  <!-- Center message removed on purpose (letters will be created and animated independently) -->
  <div class="vignette" aria-hidden="true"></div>

  <script>
  (function () {
    // Text used for big letters and for particle letters (small)
    const TEXT = 'Hello World';
    const LETTERS = 'helloworld';

    // Performance-minded config and runtime state
    const rampDuration = 10000;
    let idleTimer = null;
    let animating = false;
    let rafId = null;

    const reduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (reduced) return;

    // Input sampling to compute speed-based delay
    const mouseSamples = [];
    const sampleWindow = 600;
    const maxConsideredSpeed = 1200;
    const minDelay = 1200, maxDelay = 7000;

    const activityEvents = ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll', 'touchmove'];
    activityEvents.forEach(e => window.addEventListener(e, onActivity, { passive: true }));
    window.addEventListener('mousemove', captureMouse, { passive: true });
    window.addEventListener('touchmove', captureTouch, { passive: true });

    scheduleIdle();

    function captureMouse(ev) {
      const t = performance.now();
      mouseSamples.push({ x: ev.clientX, y: ev.clientY, t });
      pruneSamples(t);
    }
    function captureTouch(ev) {
      const t = performance.now();
      if (ev.touches && ev.touches[0]) {
        mouseSamples.push({ x: ev.touches[0].clientX, y: ev.touches[0].clientY, t });
        pruneSamples(t);
      }
    }
    function pruneSamples(now) {
      while (mouseSamples.length && now - mouseSamples[0].t > sampleWindow) mouseSamples.shift();
      if (mouseSamples.length > 30) mouseSamples.splice(0, mouseSamples.length - 30);
    }
    function computeAvgSpeed() {
      if (mouseSamples.length < 2) return 0;
      const first = mouseSamples[0];
      const last = mouseSamples[mouseSamples.length - 1];
      const dt = (last.t - first.t) / 1000;
      if (dt <= 0) return 0;
      let dist = 0;
      for (let i = 1; i < mouseSamples.length; i++) {
        const a = mouseSamples[i - 1], b = mouseSamples[i];
        dist += Math.hypot(b.x - a.x, b.y - a.y);
      }
      return dist / dt;
    }
    function onActivity(ev) {
      if (ev.type === 'mousedown' && ev.clientX != null) {
        const t = performance.now();
        mouseSamples.push({ x: ev.clientX, y: ev.clientY, t });
        pruneSamples(t);
      }
      scheduleIdle();
    }
    function scheduleIdle() {
      if (idleTimer) clearTimeout(idleTimer);
      const speed = computeAvgSpeed();
      const speedNorm = Math.min(1, Math.max(0, speed / maxConsideredSpeed));
      const mappedDelay = Math.round(lerp(minDelay, maxDelay, speedNorm));
      if (!animating) idleTimer = setTimeout(startAnimation, mappedDelay);
    }

    // Runtime pools and arrays to minimize allocations and DOM churn
    let particlePool = [];
    let particles = [];       // active small particles
    let bigLetters = [];      // active big letters
    let streams = [];
    let spawnAccumulator = 0;
    let startTime = 0;
    let lastTime = 0;

    const config = {
      spawnRateMin: 3,
      spawnRateMax: 100,
      streamsMin: 2,
      streamsMaxPerHeight: 0.010,
      particleLifeMin: 2400,
      particleLifeMax: 7000,
      vxMin: 60,
      vxMax: 520,
      verticalJitter: 26,
      maxParticles: 450,      // lowered for smoother performance
      bigVxMin: 24,
      bigVxMax: 120,
      bigLifeMin: 14000,
      bigLifeMax: 36000
    };

    function initStreams(count) {
      streams.length = 0;
      const vh = window.innerHeight;
      for (let i = 0; i < count; i++) streams.push(createStream(Math.random() * vh));
    }
    function createStream(y) {
      return { y, phase: Math.random() * Math.PI * 2, xOffset: -10 - Math.random() * 40, speedMul: 0.8 + Math.random() * 0.6, acc: 0 };
    }

    // Reuse span elements for particles to avoid GC and layout thrash
    function getParticleElement() {
      let el = particlePool.pop();
      if (el) {
        el.style.display = '';
        return el;
      }
      el = document.createElement('span');
      el.className = 'whirl-letter';
      el.style.position = 'fixed';
      el.style.left = '0px';
      el.style.top = '0px';
      el.style.willChange = 'transform, opacity';
      el.style.pointerEvents = 'none';
      el.style.userSelect = 'none';
      el.style.backfaceVisibility = 'hidden';
      return el;
    }
    function releaseParticleElement(el) {
      el.style.display = 'none';
      particlePool.push(el);
    }

    function spawnParticle(x, y, vx, vy, life, ch, size, colorHue) {
      if (particles.length >= config.maxParticles) return;
      const el = getParticleElement();
      el.textContent = ch;
      el.style.fontSize = `${size}px`;
      el.style.zIndex = 2 + Math.floor(Math.random() * 20);
      el.style.color = `hsl(${colorHue} ${56 + Math.random()*18}% ${56 + Math.random()*8}%)`;
      el.style.transform = `translate3d(${x}px, ${y}px, 0) translate(-50%,-50%) rotate(0deg) scale(1)`;
      el.style.opacity = '0.98';
      document.body.appendChild(el);
      particles.push({ el, x, y, vx, vy, birth: performance.now(), life, size });
    }

    // Create big letters from TEXT, positioned centered and then animated individually.
    let messageExploded = false;
    function explodeTextIntoBigLetters(){
      if (messageExploded) return;
      messageExploded = true;

      const vw = window.innerWidth;
      const vh = window.innerHeight;
      // emulate the CSS clamp(28px, 6vw, 84px)
      const fontSize = Math.round(Math.max(28, Math.min(84, vw * 0.06)));

      // create hidden measurement wrapper
      const wrapper = document.createElement('div');
      wrapper.style.position = 'fixed';
      wrapper.style.left = '-9999px';
      wrapper.style.top = '-9999px';
      wrapper.style.fontFamily = "'IBM Plex Mono', monospace";
      wrapper.style.fontSize = `${fontSize}px`;
      wrapper.style.fontWeight = '600';
      wrapper.style.whiteSpace = 'pre';
      wrapper.style.letterSpacing = '0.04em';
      wrapper.style.visibility = 'hidden';
      wrapper.textContent = TEXT;
      document.body.appendChild(wrapper);

      // build per-character spans to measure widths
      const spans = [];
      wrapper.innerHTML = '';
      for (const ch of TEXT) {
        const s = document.createElement('span');
        s.textContent = ch;
        s.style.display = 'inline-block';
        wrapper.appendChild(s);
        spans.push({ span: s, ch });
      }

      const rects = spans.map(s => s.span.getBoundingClientRect());
      // compute total width
      const totalWidth = rects.reduce((sum, r) => sum + r.width, 0);
      const centerX = vw / 2;
      const centerY = vh / 2;
      const startX = centerX - totalWidth / 2;

      // create big letters at measured centers
      const now = performance.now();
      let acc = 0;
      for (let i = 0; i < rects.length; i++) {
        const r = rects[i];
        const ch = spans[i].ch;
        acc += r.width;
        if (ch === ' ') {
          // skip creating element; keep spacing by advancing acc
          continue;
        }
        // center of this char
        const cx = startX + acc - (r.width / 2);
        const cy = centerY;
        const el = document.createElement('div');
        el.className = 'big-letter';
        el.textContent = ch;
        const size = Math.max(22, Math.round(r.height || fontSize));
        el.style.fontSize = `${size}px`;
        el.style.transform = `translate3d(${cx}px, ${cy}px, 0) translate(-50%,-50%) rotate(0deg) scale(1)`;
        el.style.opacity = '1';
        document.body.appendChild(el);

        const vx = lerp(config.bigVxMin, config.bigVxMax, Math.random());
        const vy = (Math.random() * 2 - 1) * 10;
        const life = randomRange(config.bigLifeMin, config.bigLifeMax);
        bigLetters.push({ el, x: cx, y: cy, vx, vy, birth: now, life, size });
      }

      // cleanup wrapper
      wrapper.remove();
    }

    function startAnimation(){
      if (animating) return;
      animating = true;
      lastTime = performance.now();
      startTime = lastTime;
      particles.length = 0;
      bigLetters.length = 0;
      streams.length = 0;
      spawnAccumulator = 0;
      initStreams(2);
      explodeTextIntoBigLetters();
      rafId = requestAnimationFrame(frame);
    }

    function stopAnimation(){
      animating = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      for (let p of particles) releaseParticleElement(p.el);
      particles.length = 0;
      for (let b of bigLetters) b.el.remove();
      bigLetters.length = 0;
      streams.length = 0;
      messageExploded = false;
    }

    // Main frame: update big letters (wrap-around) and small particles.
    function frame(now) {
      const dt = Math.min(40, now - lastTime);
      lastTime = now;
      const elapsed = now - startTime;
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      // big letters
      if (bigLetters.length) {
        const t = Math.min(1, elapsed / (rampDuration * 1.5));
        const speedMul = lerp(0.5, 1.0, easeOutCubic(t));
        for (let i = 0; i < bigLetters.length; i++) {
          const b = bigLetters[i];
          b.x += b.vx * speedMul * (dt / 1000);
          b.y += b.vy * (dt / 1000) + Math.sin((now * 0.002) + i) * 0.02 * (b.size / 24);

          if (b.x > vw + 120) {
            b.x = -120 - Math.random() * 40;
            b.y = clamp((vh * 0.15) + Math.random() * vh * 0.7, 20, vh - 20);
            b.birth = now;
          } else if (b.x < -160) {
            b.x = vw + 120;
            b.birth = now;
          }

          const rot = Math.sin((b.x + b.y) * 0.002 + i) * 16 * (b.vx / (config.bigVxMax + 0.001));
          const lifeProgress = ((now - b.birth) % b.life) / b.life;
          const opacity = 0.64 + (1 - lifeProgress) * 0.36;
          const scale = 0.92 + (1 - lifeProgress) * 0.22;

          b.el.style.transform = `translate3d(${Math.round(b.x)}px, ${Math.round(b.y)}px, 0) translate(-50%,-50%) rotate(${rot.toFixed(2)}deg) scale(${scale.toFixed(3)})`;
          b.el.style.opacity = opacity.toFixed(3);
        }
      }

      // small particles
      const tRamp = Math.min(1, elapsed / rampDuration);
      const spawnRate = lerp(config.spawnRateMin, config.spawnRateMax, easeOutCubic(tRamp));
      const vxBase = lerp(config.vxMin, config.vxMax, easeOutCubic(tRamp));

      const targetStreams = Math.max(config.streamsMin, Math.min(14, Math.round(vh * config.streamsMaxPerHeight * (0.9 + tRamp))));
      if (streams.length < targetStreams) {
        if (Math.random() < 0.12) streams.push(createStream(Math.random() * vh));
      } else if (streams.length > targetStreams) {
        streams.splice(0, streams.length - targetStreams);
      }

      const spawnFromStreams = spawnRate * 0.82;
      const strayRate = spawnRate - spawnFromStreams;
      spawnAccumulator += (strayRate * dt / 1000);
      while (spawnAccumulator >= 1) {
        spawnAccumulator -= 1;
        const y = Math.random() * vh;
        const xStart = -20 - Math.random() * 80;
        const vx = vxBase * (0.72 + Math.random() * 0.76);
        const vy = (Math.random() * 2 - 1) * 18;
        const life = randomRange(config.particleLifeMin, config.particleLifeMax) * (0.8 + Math.random()*0.8);
        const ch = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
        const size = Math.max(8, Math.min(14, (Math.min(vw, vh) / 80) * (0.6 + Math.random())));
        const hue = (200 + Math.random() * 160) % 360;
        spawnParticle(xStart, y, vx, vy, life, ch, size, hue);
      }

      const perStreamRate = spawnFromStreams / Math.max(1, streams.length);
      for (let si = 0; si < streams.length; si++) {
        const s = streams[si];
        s.acc += perStreamRate * dt / 1000;
        s.y += Math.sin((now + si*1009) * 0.00026 + s.phase) * 0.08;
        if (Math.random() < 0.002) {
          s.y += (Math.random() - 0.5) * 36;
          s.phase = Math.random() * Math.PI * 2;
        }
        while (s.acc >= 1) {
          s.acc -= 1;
          const yJitter = (Math.random() - 0.5) * 12;
          const y = clamp(s.y + yJitter, 8, vh - 8);
          const xStart = s.xOffset - (Math.random() * 18);
          const vx = vxBase * s.speedMul * (0.86 + Math.random() * 0.44);
          const vy = (Math.random() * 2 - 1) * 14;
          const life = randomRange(config.particleLifeMin, config.particleLifeMax) * (0.8 + Math.random()*1.0);
          const ch = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
          const size = Math.max(7, Math.min(12, (Math.min(vw, vh) / 100) * (0.6 + Math.random())));
          const hue = (200 + si * 10 + Math.random() * 36) % 360;
          spawnParticle(xStart, y, vx, vy, life, ch, size, hue);
        }
      }

      // update particles (minimal per-frame work)
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        const age = now - p.birth;
        if (age > p.life || p.x > vw + 80 || p.y < -120 || p.y > vh + 120) {
          releaseParticleElement(p.el);
          particles.splice(i, 1);
          continue;
        }
        p.x += p.vx * (dt / 1000);
        const flutter = Math.sin((now * 0.003) + i) * (config.verticalJitter * (0.2 + Math.sin(i) * 0.2));
        p.y += p.vy * (dt / 1000) + flutter * (dt / 1000);
        const rot = (Math.sin((p.x + p.y) * 0.002 + i) * 22) * (p.vx / (vxBase + 0.001));
        const lifeProgress = age / p.life;
        const opacity = Math.max(0, 1 - lifeProgress);
        const scale = 0.82 + (1 - lifeProgress) * 0.45;

        p.el.style.transform = `translate3d(${Math.round(p.x)}px, ${Math.round(p.y)}px, 0) translate(-50%,-50%) rotate(${rot.toFixed(2)}deg) scale(${scale.toFixed(3)})`;
        p.el.style.opacity = Math.max(0.04, opacity).toFixed(3);
      }

      if (animating) rafId = requestAnimationFrame(frame);
    }

    // Helpers
    function lerp(a, b, t) { return a + (b - a) * t; }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function randomRange(a, b) { return a + Math.random() * (b - a); }
    function easeOutCubic(x) { return 1 - Math.pow(1 - x, 3); }

    // Visibility / resize handling
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      } else if (animating && !rafId) {
        lastTime = performance.now();
        rafId = requestAnimationFrame(frame);
      }
    });

    let resizeTO;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTO);
      resizeTO = setTimeout(() => {
        if (animating) {
          const vh = window.innerHeight;
          const targetStreams = Math.max(config.streamsMin, Math.min(14, Math.round(vh * config.streamsMaxPerHeight)));
          while (streams.length < targetStreams) streams.push(createStream(Math.random() * vh));
          while (streams.length > targetStreams) streams.pop();
        }
      }, 220);
      scheduleIdle();
    });

    window.addEventListener('pagehide', () => {
      if (rafId) cancelAnimationFrame(rafId);
    });

    // Public API for debug/control
    window.__whirl = { start: startAnimation, stop: stopAnimation, scheduleIdle };

    // warm-up to reduce jank when fonts load
    window.addEventListener('load', () => {
      setTimeout(() => {
        // touch a layout measurement so fonts are ready
        const el = document.createElement('span');
        el.style.fontFamily = "'IBM Plex Mono', monospace";
        el.style.fontSize = '16px';
        el.style.visibility = 'hidden';
        el.textContent = '.';
        document.body.appendChild(el);
        el.getBoundingClientRect();
        el.remove();
      }, 200);
    });
  })();
  </script>
</body>
</html>
