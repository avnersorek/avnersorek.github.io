<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hello World â€” Whirlwind</title>

  <!-- IBM Plex Mono -->
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#07060a;
      --fg:#e9eef8;
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 800px at 10% 20%, #0b1020 0%, var(--bg) 35%, #020205 100%);
      color:var(--fg);
      font-family: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
      overflow:hidden;
    }

    /* centered Hello World in Plex Mono (will be broken into letters when animation starts) */
    #message{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      font-family: 'IBM Plex Mono', monospace;
      font-size:clamp(28px,6vw,84px);
      letter-spacing:0.04em;
      font-weight:600;
      color:var(--fg);
      text-align:center;
      z-index:3;
      pointer-events:none;
      transition:opacity 0.8s ease, transform 0.8s ease;
      text-shadow:
        0 6px 20px rgba(2,3,9,0.7),
        0 1px 0 rgba(255,255,255,0.02);
      white-space:nowrap;
    }

    /* particle letters (small, mono) */
    .whirl-letter{
      position:fixed;
      left:0;
      top:0;
      transform-origin:center center;
      will-change:transform, opacity, filter;
      pointer-events:none;
      user-select:none;
      font-family:'IBM Plex Mono', monospace;
      font-weight:400;
      mix-blend-mode:screen;
      text-shadow:
        0 2px 6px rgba(0,0,0,0.5);
    }

    .vignette{
      position:fixed;
      inset:0;
      background:
        radial-gradient(60% 40% at 20% 30%, rgba(80,120,255,0.05), transparent 10%),
        radial-gradient(50% 35% at 80% 80%, rgba(255,140,200,0.03), transparent 12%);
      pointer-events:none;
      z-index:1;
    }

    @media (prefers-reduced-motion: reduce){
      .whirl-letter{ transition:none !important; animation:none !important; opacity:0 !important; }
    }
  </style>
</head>
<body>
  <div id="message">Hello World</div>
  <div class="vignette" aria-hidden="true"></div>

  <script>
  (function () {
    // Lowercase letters allowed (words "hello world")
    const LETTERS = 'helloworld';
    const idleDelay = 5000;     // ms before auto-start
    const rampDuration = 10000; // ms to go from slow to full speed
    let idleTimer = null;
    let animating = false;
    let rafId = null;

    const message = document.getElementById('message');

    // Respect reduced motion preference
    const reduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (reduced) {
      // keep simple message visible and do nothing else
      return;
    }

    // Interaction resets idle and stops animation
    const activityEvents = ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll'];
    activityEvents.forEach(e => window.addEventListener(e, resetIdle, { passive: true }));

    resetIdle();

    function resetIdle(){
      if (idleTimer) clearTimeout(idleTimer);
      if (animating) stopAnimation();
      idleTimer = setTimeout(() => startAnimation(), idleDelay);
    }

    function startAnimation(){
      animating = true;
      lastTime = performance.now();
      startTime = lastTime;
      particles = [];
      streams = [];
      spawnAccumulator = 0;

      // Reduced initial streams for performance
      initStreams(2);

      // Break the central message into letters that become particles ("fly away")
      explodeMessage();

      rafId = requestAnimationFrame(frame);
    }

    function stopAnimation(){
      animating = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      // remove DOM nodes
      particles.forEach(p => p.el.remove());
      particles = [];
      streams = [];
      // restore message if it was removed
      if (!document.body.contains(message)) {
        // recreate message node for a static fallback
        const m = document.createElement('div');
        m.id = 'message';
        m.textContent = 'Hello World';
        m.style.position = 'fixed';
        m.style.left = '50%';
        m.style.top = '50%';
        m.style.transform = 'translate(-50%,-50%)';
        m.style.fontFamily = "'IBM Plex Mono', monospace";
        m.style.fontSize = 'clamp(28px,6vw,84px)';
        m.style.letterSpacing = '0.04em';
        m.style.fontWeight = '600';
        m.style.color = 'var(--fg)';
        m.style.textAlign = 'center';
        m.style.zIndex = '3';
        m.style.pointerEvents = 'none';
        m.style.textShadow = '0 6px 20px rgba(2,3,9,0.7), 0 1px 0 rgba(255,255,255,0.02)';
        document.body.appendChild(m);
      }
    }

    // Particles currently on screen
    let particles = [];
    // Streams that emit letters (horizontal "columns" moving left->right)
    let streams = [];
    // Accumulators
    let spawnAccumulator = 0;
    let startTime = 0;
    let lastTime = 0;

    // Config: toned-down numbers for improved performance
    const config = {
      spawnRateMin: 3,        // letters/sec at start (global) - reduced
      spawnRateMax: 120,      // letters/sec at full speed - reduced
      streamsMin: 2,
      streamsMaxPerHeight: 0.012, // fewer streams per height
      particleLifeMin: 2400,  // ms
      particleLifeMax: 7000,  // ms
      vxMin: 60,              // px/s at start
      vxMax: 520,             // px/s at top speed
      verticalJitter: 28,     // px amplitude for leaf-like flutter
      maxParticles: 800,      // reduced ceiling
    };

    function initStreams(count) {
      streams = [];
      const vh = window.innerHeight;
      for (let i = 0; i < count; i++) {
        const y = Math.random() * vh;
        streams.push(createStream(y));
      }
    }

    function createStream(y) {
      return {
        y,
        phase: Math.random() * Math.PI * 2,
        xOffset: -10 - Math.random() * 60,
        speedMul: 0.8 + Math.random() * 0.7,
        acc: 0
      };
    }

    // Spawn a particle at (x,y) moving rightwards
    function spawnParticle(x, y, vx, vy, life, ch, size, colorHue) {
      if (particles.length > config.maxParticles) return;
      const el = document.createElement('span');
      el.className = 'whirl-letter';
      el.textContent = ch;
      el.style.left = '0px';
      el.style.top = '0px';
      el.style.fontSize = `${size}px`;
      el.style.opacity = '0.98';
      el.style.zIndex = 2 + Math.floor(Math.random() * 20);
      el.style.color = `hsl(${colorHue} ${58 + Math.random()*20}% ${56 + Math.random()*8}%)`;
      document.body.appendChild(el);

      particles.push({
        el,
        x, y,
        vx, vy,
        birth: performance.now(),
        life,
        size
      });
    }

    // When animation starts, break the centered message into letters that fly away
    function explodeMessage() {
      if (!message) return;
      const rect = message.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      // take visible characters from message, keep case but only use letters from allowed set
      const text = message.textContent || '';
      let chars = [];
      for (let ch of text) {
        const low = ch.toLowerCase();
        if (low === ' ') {
          // create a small gap particle occasionally for a natural look (optional)
          if (Math.random() < 0.2) chars.push(' ');
          else chars.push(' ');
          continue;
        }
        // map any character to nearest allowed letter (for consistency use allowed letters)
        if (LETTERS.includes(low)) chars.push(low);
        else chars.push(LETTERS[Math.floor(Math.random() * LETTERS.length)]);
      }

      // Remove the message element so letters are represented only by particles
      message.remove();

      // spawn each letter as a particle with a small stagger
      chars.forEach((ch, i) => {
        const delay = i * 30 + Math.random() * 120; // stagger
        setTimeout(() => {
          // choose small size for these letters but slightly larger than stream letters
          const vw = window.innerWidth;
          const vh = window.innerHeight;
          const size = Math.max(12, Math.min(26, (Math.min(vw, vh) / 60) * (0.9 + Math.random() * 0.6)));
          // initial velocities biased rightwards, with some vertical component
          const baseVX = lerp(config.vxMin, config.vxMax, 0.7) * (0.9 + Math.random() * 0.5);
          const vx = baseVX * (0.9 + Math.random() * 0.6);
          const vy = (Math.random() * 2 - 1) * 40;
          const life = randomRange(config.particleLifeMin * 0.8, config.particleLifeMax * 1.1);
          const hue = (200 + Math.random() * 160) % 360;
          // if character is a space, spawn a faint tiny glyph from LETTERS
          const c = (ch === ' ') ? LETTERS[Math.floor(Math.random() * LETTERS.length)] : ch;
          spawnParticle(centerX + (Math.random()-0.5)*rect.width, centerY + (Math.random()-0.5)*rect.height, vx, vy, life, c, size, hue);
        }, delay);
      });
    }

    // Frame loop
    function frame(now) {
      const dt = Math.min(40, now - lastTime); // clamp to avoid jumps
      lastTime = now;
      const elapsed = now - startTime;
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      // Ramp factor (0 -> 1)
      const t = Math.min(1, elapsed / rampDuration);

      // compute current global spawn rate and speed based on ramp
      const spawnRate = lerp(config.spawnRateMin, config.spawnRateMax, easeOutCubic(t));
      const vxBase = lerp(config.vxMin, config.vxMax, easeOutCubic(t));

      // adjust number of streams gradually (kept conservative)
      const targetStreams = Math.max(config.streamsMin, Math.min(24, Math.round(vh * config.streamsMaxPerHeight * (0.9 + t))));
      if (streams.length < targetStreams) {
        if (Math.random() < 0.12) streams.push(createStream(Math.random() * vh));
      } else if (streams.length > targetStreams) {
        streams.splice(0, streams.length - targetStreams);
      }

      // distribute spawnRate across streams but allow some random stray particles
      const spawnFromStreams = spawnRate * 0.82;
      const strayRate = spawnRate - spawnFromStreams;

      // accumulate and emit stray particles
      spawnAccumulator += (strayRate * dt / 1000);
      while (spawnAccumulator >= 1) {
        spawnAccumulator -= 1;
        const y = Math.random() * vh;
        const xStart = -20 - Math.random() * 80;
        const vx = vxBase * (0.7 + Math.random() * 0.8);
        const vy = (Math.random() * 2 - 1) * 24;
        const life = randomRange(config.particleLifeMin, config.particleLifeMax) * (0.8 + Math.random()*0.8);
        const ch = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
        const size = Math.max(8, Math.min(16, (Math.min(vw, vh) / 70) * (0.6 + Math.random())));
        const hue = (200 + Math.random() * 160) % 360;
        spawnParticle(xStart, y, vx, vy, life, ch, size, hue);
      }

      // each stream emits according to spawnFromStreams / streams.length
      const perStreamRate = spawnFromStreams / Math.max(1, streams.length);
      for (let si = 0; si < streams.length; si++) {
        const s = streams[si];
        s.acc += perStreamRate * dt / 1000;
        // gently drift vertical position to simulate different currents
        s.y += Math.sin((now + si*1009) * 0.00026 + s.phase) * 0.08;
        if (Math.random() < 0.002) {
          s.y += (Math.random() - 0.5) * 36;
          s.phase = Math.random() * Math.PI * 2;
        }
        while (s.acc >= 1) {
          s.acc -= 1;
          const yJitter = (Math.random() - 0.5) * 14;
          const y = clamp(s.y + yJitter, 8, vh - 8);
          const xStart = s.xOffset - (Math.random() * 18);
          const vx = vxBase * s.speedMul * (0.85 + Math.random() * 0.5);
          const vy = (Math.random() * 2 - 1) * 18;
          const life = randomRange(config.particleLifeMin, config.particleLifeMax) * (0.8 + Math.random()*1.0);
          const ch = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
          const size = Math.max(7, Math.min(14, (Math.min(vw, vh) / 90) * (0.6 + Math.random())));
          const hue = (200 + si * 10 + Math.random() * 36) % 360;
          spawnParticle(xStart, y, vx, vy, life, ch, size, hue);
        }
      }

      // update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        const age = now - p.birth;
        if (age > p.life || p.x > vw + 80 || p.y < -120 || p.y > vh + 120) {
          p.el.remove();
          particles.splice(i, 1);
          continue;
        }
        // horizontal movement
        p.x += p.vx * (dt / 1000);
        // vertical movement plus fluttering to mimic leaves
        const flutter = Math.sin((now * 0.003) + i) * (config.verticalJitter * (0.2 + Math.sin(i)*0.2));
        p.y += p.vy * (dt / 1000) + flutter * (dt / 1000);

        // slight rotation based on vx and flutter
        const rot = (Math.sin((p.x + p.y) * 0.002 + i) * 24) * (p.vx / (vxBase + 0.001));

        // opacity fades out towards end of life
        const lifeProgress = age / p.life;
        const opacity = Math.max(0, 1 - lifeProgress);
        const scale = 0.82 + (1 - lifeProgress) * 0.5;

        p.el.style.transform = `translate(${p.x}px, ${p.y}px) translate(-50%, -50%) rotate(${rot}deg) scale(${scale})`;
        p.el.style.opacity = Math.max(0.04, opacity).toFixed(3);
        p.el.style.filter = `blur(${Math.min(1.8, lifeProgress * 2)}px)`;
      }

      // schedule next frame if animating
      if (animating) rafId = requestAnimationFrame(frame);
    }

    // helpers
    function lerp(a, b, t) { return a + (b - a) * t; }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function randomRange(a, b) { return a + Math.random() * (b - a); }
    function easeOutCubic(x) { return 1 - Math.pow(1 - x, 3); }

    // Pause/resume on visibility change for efficiency
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      } else if (animating && !rafId) {
        lastTime = performance.now();
        rafId = requestAnimationFrame(frame);
      }
    });

    // Rebuild streams on resize to keep density correct
    let resizeTO;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTO);
      resizeTO = setTimeout(() => {
        if (animating) {
          const vh = window.innerHeight;
          const targetStreams = Math.max(config.streamsMin, Math.min(24, Math.round(vh * config.streamsMaxPerHeight)));
          while (streams.length < targetStreams) streams.push(createStream(Math.random() * vh));
          while (streams.length > targetStreams) streams.pop();
        }
      }, 220);
      resetIdle();
    });

    // cleanup
    window.addEventListener('pagehide', () => {
      if (rafId) cancelAnimationFrame(rafId);
    });

    // Expose control for debugging
    window.__whirl = {
      start: startAnimation,
      stop: stopAnimation,
      resetIdle
    };
  })();
  </script>
</body>
</html>
